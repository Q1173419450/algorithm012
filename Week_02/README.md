## 学习笔记

### 习惯

1、clarification

2、possible solutions --> optimal(time & space)

3、code

4、test cases

### map 和 set

底层使用：哈希表

> Hash Collisions（哈希碰撞）

拉链表解决冲突

> 查询、添加、删除时间复杂度

O(1) => O(n)

> 空间复杂度

O(1)

### 树、二叉树、二叉搜索树

Linked List 是特殊化的 Tree
Tree 是特殊化的 Graph

> 二叉树节点关系

```
      1
    /   \
   2     3
  /  \  / \
 4   5 6   7
```

根节点：
父节点：1 就是 2、3 的父节点
子节点：2、3 就是 1 的子节点
兄弟节点：
叶子节点：

树的：
  高度（Height）：根节点到叶子节点递减。山顶到山底
  深度（Depth）：根节点到叶子节点递增。水面到水底
  层（Level）：深度 + 1

> 特殊的树

满二叉树: 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树。

完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。

> 存储方式

- 顺序存储法
  - 如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。
  - 如果是非完全二叉树，其实会浪费比较多的数组存储空间。如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。

> 二叉树的遍历（O(N)）

前序：根左右。对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

中序：左根右。对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

后序：左右根。对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

递归

> 二叉搜索树（O(logN)）

1. 左子树上所有结点的值均小于它的根结点的值；

2. 右子树上所有结点的值均大于它的根结点的值；

3. 使用中序遍历即可得到一个排序好的数组

- 重复数据的二叉查找树
  - 1、二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
  - 2、在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。
  - 当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。

### 堆

是一颗完全树

树中任意节点的值总是 >= 子节点

### 图
